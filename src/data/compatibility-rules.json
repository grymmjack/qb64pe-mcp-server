{
  "version": "1.0.0",
  "lastUpdated": "2024-12-24",
  "categories": {
    "syntax_issues": {
      "function_return_types": {
        "title": "Function Return Type Declaration",
        "description": "QB64PE doesn't support AS TYPE syntax for function return types",
        "invalid_patterns": [
          "FUNCTION\\s+\\w+\\([^)]*\\)\\s+AS\\s+\\w+"
        ],
        "error_messages": [
          "Expected )"
        ],
        "corrections": [
          {
            "problem": "FUNCTION name(params) AS TYPE",
            "solution": "FUNCTION name%(params) for INTEGER, name&(params) for LONG, etc.",
            "explanation": "Use type sigils instead of AS clauses"
          }
        ],
        "type_sigils": {
          "%": "INTEGER",
          "&": "LONG",
          "!": "SINGLE",
          "#": "DOUBLE",
          "$": "STRING"
        },
        "examples": [
          {
            "incorrect": "FUNCTION NearestPaletteIndex(r AS INTEGER, g AS INTEGER, b AS INTEGER) AS INTEGER",
            "correct": "FUNCTION NearestPaletteIndex%(r AS INTEGER, g AS INTEGER, b AS INTEGER)"
          }
        ]
      },
      "console_directives": {
        "title": "Console Mode Directives",
        "description": "Invalid console directive syntax",
        "invalid_patterns": [
          "\\$CONSOLE:OFF"
        ],
        "error_messages": [
          "Syntax error - Caused by (or after):$ CONSOLE"
        ],
        "valid_directives": {
          "$CONSOLE": "Shows both console and graphics windows",
          "$CONSOLE:ONLY": "Console mode only (no graphics)",
          "no directive": "Graphics only"
        },
        "examples": [
          {
            "incorrect": "$CONSOLE:OFF",
            "correct": "$CONSOLE",
            "note": "$CONSOLE:OFF is not valid syntax"
          }
        ]
      },
      "multi_statement_lines": {
        "title": "Multiple IF Statements on One Line",
        "description": "Chained control structures cause parsing errors",
        "invalid_patterns": [
          "IF\\s+.+\\s+THEN\\s+.+:\\s*IF\\s+.+\\s+THEN"
        ],
        "error_messages": [
          "THEN without IF"
        ],
        "rule": "Avoid complex multi-statement lines, especially with control structures",
        "examples": [
          {
            "incorrect": "IF r < 0 THEN r = 0: IF r > 255 THEN r = 255",
            "correct": "IF r < 0 THEN r = 0\\nIF r > 255 THEN r = 255"
          }
        ]
      },
      "array_declarations": {
        "title": "Multiple Array Declarations on One Line",
        "description": "Multiple arrays with dimensions cannot be declared on one line",
        "invalid_patterns": [
          "DIM\\s+\\w+\\([^)]+\\)\\s+AS\\s+\\w+,\\s*\\w+\\([^)]+\\)\\s+AS\\s+\\w+"
        ],
        "error_messages": [
          "DIM: Expected ,"
        ],
        "examples": [
          {
            "incorrect": "DIM er#(0 TO w) AS DOUBLE, eg#(0 TO w) AS DOUBLE, eb#(0 TO w) AS DOUBLE",
            "correct": "DIM er(0 TO w) AS DOUBLE\\nDIM eg(0 TO w) AS DOUBLE\\nDIM eb(0 TO w) AS DOUBLE"
          }
        ]
      },
      "variable_operations": {
        "title": "Multiple Variable Operations on One Line",
        "description": "Combining declarations and assignments causes parsing issues",
        "invalid_patterns": [
          "DIM\\s+\\w+\\s+AS\\s+\\w+:\\s*\\w+\\s*="
        ],
        "examples": [
          {
            "incorrect": "DIM oldS AS LONG: oldS = _SOURCE: _SOURCE img",
            "correct": "DIM oldS AS LONG\\noldS = _SOURCE\\n_SOURCE img"
          }
        ]
      },
      "missing_functions": {
        "title": "Missing String Functions",
        "description": "Some expected BASIC string functions don't exist in QB64PE",
        "missing_functions": [
          "_WORD$",
          "_TRIM$"
        ],
        "alternatives": {
          "_WORD$": "Use INSTR, MID$, LEFT$, RIGHT$ for string parsing",
          "_TRIM$": "Use LTRIM$ and RTRIM$ or implement custom trim function"
        },
        "examples": [
          {
            "incorrect": "r = VAL(_TRIM$(_WORD$(line$, 1, \" \")))",
            "correct": "pos1 = INSTR(line$, \" \")\\nIF pos1 > 0 THEN r = VAL(LEFT$(line$, pos1 - 1))"
          }
        ]
      }
    },
    "unsupported_keywords": {
      "legacy_statements": {
        "title": "Legacy BASIC Keywords Not Supported",
        "keywords": [
          "ALIAS",
          "ANY", 
          "BYVAL",
          "CALLS",
          "CDECL",
          "DECLARE",
          "DEF FN",
          "EXIT DEF", 
          "END DEF",
          "ERDEV",
          "ERDEV$",
          "FILEATTR",
          "FRE",
          "IOCTL",
          "IOCTL$"
        ],
        "notes": {
          "ALIAS": "Only supported in DECLARE LIBRARY",
          "BYVAL": "Only supported in DECLARE LIBRARY",
          "DATE$": "Statement form not supported, reading current DATE$ is supported",
          "DEF FN": "Must use actual FUNCTIONs instead",
          "TIME$": "Statement form not supported, reading current TIME$ is supported"
        }
      },
      "device_hardware": {
        "title": "Device and Hardware Access Keywords",
        "keywords": [
          "ON PEN",
          "PEN",
          "ON PLAY(n)",
          "PLAY(n) ON/OFF/STOP",
          "ON UEVENT",
          "UEVENT",
          "SETMEM",
          "SIGNAL",
          "TRON",
          "TROFF",
          "WIDTH LPRINT"
        ],
        "device_opens": [
          "LPT:",
          "CON:",
          "KBRD:"
        ],
        "notes": {
          "OPEN devices": "LPRINT and OPEN COM are supported",
          "PLAY": "PLAY music is supported, but not PLAY(n) ON/OFF/STOP"
        }
      },
      "platform_specific": {
        "title": "Platform-Specific Limitations",
        "linux_macos_unsupported": {
          "desktop_operations": [
            "_ACCEPTFILEDROP",
            "_TOTALDROPPEDFILES", 
            "_DROPPEDFILE",
            "_FINISHDROP",
            "_SCREENPRINT",
            "_SCREENCLICK",
            "_WINDOWHANDLE",
            "_CAPSLOCK",
            "_NUMLOCK", 
            "_SCROLLLOCK"
          ],
          "console_operations": [
            "_CONSOLETITLE",
            "_CONSOLECURSOR",
            "_CONSOLEFONT",
            "_CONSOLEINPUT",
            "_CINP"
          ],
          "program_control": [
            "CHAIN",
            "RUN"
          ],
          "printing": [
            "LPRINT",
            "_PRINTIMAGE"
          ],
          "hardware_access": [
            "OPEN COM",
            "LOCK",
            "UNLOCK"
          ]
        },
        "partial_support": {
          "_SCREENMOVE": "Available in macOS, not Linux",
          "_WINDOWHASFOCUS": "Available in Linux, not macOS"
        }
      }
    },
    "variable_scoping": {
      "title": "Variable Scoping and SHARED Variables",
      "description": "QB64PE variable scoping rules and how to properly share variables between procedures",
      "scope_rules": {
        "local_scope": {
          "description": "Variables declared in SUB/FUNCTION are local by default",
          "rules": [
            "Variables declared with DIM inside SUB/FUNCTION are local to that procedure",
            "Local variables cannot be accessed from other procedures",
            "Local variables are automatically destroyed when procedure exits",
            "Parameters passed to SUB/FUNCTION are local to that procedure"
          ]
        },
        "global_scope": {
          "description": "Variables declared in main program are global by default",
          "rules": [
            "Variables declared in main program (outside SUB/FUNCTION) are global",
            "Global variables can be accessed from any procedure using SHARED",
            "Global variables persist throughout program execution"
          ]
        },
        "shared_variables": {
          "description": "SHARED keyword allows procedures to access global variables",
          "syntax": [
            "DIM SHARED variableName AS dataType",
            "DIM SHARED arrayName(size) AS dataType",
            "SHARED variableName  ' Reference existing global variable"
          ],
          "rules": [
            "DIM SHARED creates a new global variable accessible from all procedures",
            "SHARED (without DIM) references an existing global variable",
            "SHARED must be declared at the beginning of each procedure that needs access",
            "Arrays declared with DIM SHARED are global and accessible from all procedures"
          ]
        }
      },
      "common_issues": {
        "variable_not_in_scope": {
          "problem": "Attempting to access variables from SUB/FUNCTION without proper scoping",
          "symptoms": [
            "Variable not found errors",
            "Unexpected zero or empty values",
            "Type mismatch errors"
          ],
          "solutions": [
            "Use DIM SHARED for variables that need global access",
            "Pass variables as parameters to SUB/FUNCTION",
            "Declare SHARED within procedures to access global variables"
          ]
        },
        "missing_shared_declaration": {
          "problem": "Global variables not accessible in procedures",
          "solution": "Add SHARED declaration at the beginning of SUB/FUNCTION",
          "example": {
            "incorrect": "SUB MyProc\\n    globalVar = 10  ' Error: globalVar not accessible",
            "correct": "SUB MyProc\\n    SHARED globalVar\\n    globalVar = 10  ' Now accessible"
          }
        },
        "array_scope_issues": {
          "problem": "Arrays not properly shared between procedures",
          "solution": "Use DIM SHARED for arrays that need global access",
          "example": {
            "incorrect": "DIM myArray(100) AS INTEGER  ' Local to main\\nCALL ProcessArray  ' Array not accessible in SUB",
            "correct": "DIM SHARED myArray(100) AS INTEGER  ' Global access\\nCALL ProcessArray  ' Array accessible in SUB"
          }
        }
      },
      "dynamic_arrays": {
        "title": "Dynamic Array Management",
        "description": "QB64PE supports dynamic arrays with proper directives",
        "directive": {
          "syntax": "'$DYNAMIC",
          "purpose": "Allows arrays to be resized at runtime using REDIM",
          "placement": "Must be placed before any array declarations that will be resized"
        },
        "static_vs_dynamic": {
          "static_arrays": {
            "characteristics": [
              "Size fixed at compile time",
              "Faster access",
              "Memory allocated at compile time",
              "Default behavior in QB64PE"
            ],
            "syntax": "DIM arrayName(constantSize) AS dataType"
          },
          "dynamic_arrays": {
            "characteristics": [
              "Size can be changed at runtime",
              "Slightly slower access",
              "Memory allocated at runtime",
              "Requires $DYNAMIC directive"
            ],
            "syntax": [
              "'$DYNAMIC",
              "DIM arrayName() AS dataType  ' Empty parentheses",
              "REDIM arrayName(newSize) AS dataType  ' Resize as needed"
            ]
          }
        },
        "best_practices": [
          "Use static arrays when size is known and fixed",
          "Use dynamic arrays when size varies based on input or conditions",
          "Place $DYNAMIC directive before first dynamic array declaration",
          "Use REDIM PRESERVE to keep existing data when resizing",
          "Be mindful of memory usage with large dynamic arrays"
        ]
      },
      "array_resizing": {
        "title": "Array Resizing and Boundary Management",
        "description": "Comprehensive guide to resizing arrays and managing array boundaries safely",
        "redim_statements": {
          "REDIM": {
            "purpose": "Resize dynamic arrays at runtime",
            "syntax": "REDIM arrayName(newSize) AS dataType",
            "behavior": [
              "Destroys existing array contents",
              "Allocates new memory with specified size",
              "Can only be used with arrays declared with empty dimensions DIM arrayName()",
              "Requires $DYNAMIC directive to be in effect",
              "Can resize multiple dimensions: REDIM array(x, y, z)"
            ],
            "limitations": [
              "Cannot change the number of dimensions",
              "Cannot change the data type",
              "All existing data is lost unless using PRESERVE"
            ]
          },
          "REDIM_PRESERVE": {
            "purpose": "Resize arrays while preserving existing data",
            "syntax": "REDIM PRESERVE arrayName(newSize) AS dataType",
            "behavior": [
              "Keeps existing data that fits in new size",
              "Only allows changing the last dimension in multi-dimensional arrays",
              "Data beyond new boundaries is lost if shrinking",
              "New elements are initialized to zero/empty string"
            ],
            "limitations": [
              "Slower than regular REDIM due to data copying",
              "Multi-dimensional arrays can only resize the last dimension",
              "Memory usage may be higher during resize operation"
            ]
          },
          "REDIM_SHARED": {
            "purpose": "Resize shared arrays that are accessible across procedures",
            "syntax": "REDIM SHARED arrayName(newSize) AS dataType",
            "behavior": [
              "Creates or resizes a global array accessible from all procedures",
              "Combines REDIM functionality with SHARED scoping",
              "Can be called from within SUB/FUNCTION procedures",
              "Affects the global array, not a local copy"
            ],
            "use_cases": [
              "Resizing global arrays from within procedures",
              "Creating dynamic global arrays at runtime",
              "Managing shared data structures that change size"
            ]
          }
        },
        "boundary_functions": {
          "UBOUND": {
            "purpose": "Returns the upper boundary (maximum index) of an array dimension",
            "syntax": [
              "UBOUND(arrayName) ' For single dimension",
              "UBOUND(arrayName, dimension) ' For specific dimension"
            ],
            "behavior": [
              "Returns highest valid index for the dimension",
              "Works with both static and dynamic arrays",
              "First dimension is 1, second is 2, etc.",
              "Essential for safe array iteration"
            ],
            "examples": [
              "FOR i = 0 TO UBOUND(myArray): PRINT myArray(i): NEXT",
              "maxRows = UBOUND(grid, 1): maxCols = UBOUND(grid, 2)"
            ]
          },
          "LBOUND": {
            "purpose": "Returns the lower boundary (minimum index) of an array dimension",
            "syntax": [
              "LBOUND(arrayName) ' For single dimension",
              "LBOUND(arrayName, dimension) ' For specific dimension"
            ],
            "behavior": [
              "Returns lowest valid index for the dimension",
              "Usually 0 for QB64PE arrays (unless using TO keyword)",
              "Works with both static and dynamic arrays",
              "Important for arrays with custom lower bounds"
            ],
            "examples": [
              "FOR i = LBOUND(myArray) TO UBOUND(myArray): PRINT myArray(i): NEXT",
              "DIM customArray(5 TO 15): ' LBOUND = 5, UBOUND = 15"
            ]
          }
        },
        "safe_array_practices": {
          "boundary_checking": [
            "Always use UBOUND and LBOUND for loop boundaries",
            "Check array bounds before accessing elements",
            "Use boundary functions instead of hardcoded values",
            "Validate input indices before array access"
          ],
          "resizing_strategies": [
            "Use REDIM PRESERVE when existing data must be kept",
            "Plan for growth patterns to minimize resize operations",
            "Consider memory constraints with large arrays",
            "Test resize operations with edge cases (empty arrays, single elements)"
          ],
          "error_prevention": [
            "Check if array is allocated before resizing",
            "Validate new size parameters before REDIM",
            "Use error handling around resize operations",
            "Document array size expectations in comments"
          ]
        },
        "common_patterns": {
          "dynamic_growth": {
            "description": "Growing arrays as needed to accommodate new data",
            "example_code": [
              "'$DYNAMIC",
              "DIM SHARED dataArray() AS STRING",
              "DIM SHARED itemCount AS INTEGER",
              "",
              "SUB AddItem(newItem AS STRING)",
              "    ' Grow array if needed",
              "    IF itemCount = 0 THEN",
              "        REDIM SHARED dataArray(0 TO 0)",
              "    ELSE",
              "        REDIM PRESERVE SHARED dataArray(0 TO itemCount)",
              "    END IF",
              "    ",
              "    ' Add new item",
              "    dataArray(itemCount) = newItem",
              "    itemCount = itemCount + 1",
              "END SUB"
            ]
          },
          "safe_iteration": {
            "description": "Safely iterating through arrays using boundary functions",
            "example_code": [
              "SUB ProcessArray(arr() AS INTEGER)",
              "    ' Check if array has elements",
              "    IF UBOUND(arr) >= LBOUND(arr) THEN",
              "        FOR i = LBOUND(arr) TO UBOUND(arr)",
              "            ' Process arr(i) safely",
              "            PRINT \"Element \"; i; \" = \"; arr(i)",
              "        NEXT i",
              "    ELSE",
              "        PRINT \"Array is empty\"",
              "    END IF",
              "END SUB"
            ]
          },
          "multi_dimensional_resize": {
            "description": "Resizing multi-dimensional arrays properly",
            "example_code": [
              "'$DYNAMIC",
              "DIM SHARED grid() AS INTEGER",
              "",
              "SUB ResizeGrid(newRows AS INTEGER, newCols AS INTEGER)",
              "    ' For multi-dimensional arrays, can only preserve last dimension",
              "    IF newRows <> 0 AND newCols <> 0 THEN",
              "        REDIM SHARED grid(0 TO newRows - 1, 0 TO newCols - 1)",
              "        PRINT \"Grid resized to \"; newRows; \" x \"; newCols",
              "    END IF",
              "END SUB",
              "",
              "SUB ShowGridBounds",
              "    PRINT \"Rows: \"; LBOUND(grid, 1); \" TO \"; UBOUND(grid, 1)",
              "    PRINT \"Cols: \"; LBOUND(grid, 2); \" TO \"; UBOUND(grid, 2)",
              "END SUB"
            ]
          },
          "conditional_resizing": {
            "description": "Resizing based on data requirements with bounds checking",
            "example_code": [
              "'$DYNAMIC",
              "DIM SHARED buffer() AS DOUBLE",
              "",
              "SUB EnsureCapacity(requiredSize AS INTEGER)",
              "    DIM currentSize AS INTEGER",
              "    ",
              "    ' Check current array size",
              "    currentSize = -1  ' Default for unallocated array",
              "    IF UBOUND(buffer) >= LBOUND(buffer) THEN",
              "        currentSize = UBOUND(buffer) - LBOUND(buffer) + 1",
              "    END IF",
              "    ",
              "    ' Resize if needed",
              "    IF currentSize < requiredSize THEN",
              "        IF currentSize = -1 THEN",
              "            ' First allocation",
              "            REDIM SHARED buffer(0 TO requiredSize - 1)",
              "        ELSE",
              "            ' Grow existing array",
              "            REDIM PRESERVE SHARED buffer(0 TO requiredSize - 1)",
              "        END IF",
              "        PRINT \"Buffer resized to \"; requiredSize; \" elements\"",
              "    END IF",
              "END SUB"
            ]
          }
        },
        "troubleshooting": {
          "common_errors": {
            "subscript_out_of_range": {
              "cause": "Accessing array index outside LBOUND to UBOUND range",
              "solution": "Always check bounds with UBOUND/LBOUND before access",
              "prevention": "Use boundary functions in loop conditions"
            },
            "array_not_defined": {
              "cause": "Attempting to REDIM an array not declared with empty dimensions",
              "solution": "Declare with DIM arrayName() AS type before using REDIM",
              "prevention": "Always declare dynamic arrays with empty parentheses"
            },
            "preserve_dimension_error": {
              "cause": "Trying to REDIM PRESERVE non-last dimension in multi-dimensional array",
              "solution": "Only resize the last dimension when using PRESERVE",
              "prevention": "Design arrays with resizable dimension last"
            },
            "static_array_redim": {
              "cause": "Attempting to REDIM a static array (declared with fixed size)",
              "solution": "Declare as dynamic array with empty dimensions",
              "prevention": "Use $DYNAMIC directive and empty parentheses for resizable arrays"
            }
          },
          "debugging_tips": [
            "Print LBOUND and UBOUND values before array operations",
            "Use error handling around REDIM operations",
            "Test with empty arrays and single-element arrays",
            "Verify $DYNAMIC directive is in correct location",
            "Check for proper SHARED declarations in multi-procedure code"
          ]
        }
      },
      "examples": {
        "proper_shared_usage": {
          "description": "Correct way to share variables between procedures",
          "code": [
            "' Global variables declared in main program",
            "DIM SHARED playerScore AS LONG",
            "DIM SHARED gameBoard(8, 8) AS INTEGER",
            "",
            "' Main program",
            "playerScore = 0",
            "InitializeBoard",
            "PlayGame",
            "END",
            "",
            "SUB InitializeBoard",
            "    ' No need to declare SHARED here since gameBoard was DIM SHARED",
            "    FOR i = 0 TO 8",
            "        FOR j = 0 TO 8",
            "            gameBoard(i, j) = 0",
            "        NEXT j",
            "    NEXT i",
            "END SUB",
            "",
            "SUB PlayGame",
            "    ' No need to declare SHARED here since playerScore was DIM SHARED",
            "    playerScore = playerScore + 100",
            "    PRINT \"Score:\"; playerScore",
            "END SUB"
          ]
        },
        "local_shared_reference": {
          "description": "Referencing existing global variables in procedures",
          "code": [
            "' Global variable in main program",
            "DIM currentLevel AS INTEGER",
            "currentLevel = 1",
            "",
            "CheckLevel",
            "END",
            "",
            "SUB CheckLevel",
            "    ' Reference the global variable",
            "    SHARED currentLevel",
            "    IF currentLevel > 10 THEN",
            "        PRINT \"Max level reached!\"",
            "    ELSE",
            "        currentLevel = currentLevel + 1",
            "    END IF",
            "END SUB"
          ]
        },
        "dynamic_array_example": {
          "description": "Using dynamic arrays with proper directives",
          "code": [
            "'$DYNAMIC",
            "DIM SHARED dataArray() AS DOUBLE",
            "",
            "' Main program",
            "LoadData \"numbers.txt\"",
            "ProcessData",
            "END",
            "",
            "SUB LoadData(filename AS STRING)",
            "    ' dataArray is already SHARED, so accessible here",
            "    OPEN filename FOR INPUT AS #1",
            "    ' Count lines first",
            "    lineCount = 0",
            "    WHILE NOT EOF(1)",
            "        INPUT #1, temp",
            "        lineCount = lineCount + 1",
            "    WEND",
            "    CLOSE #1",
            "    ",
            "    ' Resize array to fit data",
            "    REDIM dataArray(lineCount - 1)",
            "    ",
            "    ' Load actual data",
            "    OPEN filename FOR INPUT AS #1",
            "    FOR i = 0 TO lineCount - 1",
            "        INPUT #1, dataArray(i)",
            "    NEXT i",
            "    CLOSE #1",
            "END SUB",
            "",
            "SUB ProcessData",
            "    ' Process the shared dynamic array",
            "    FOR i = 0 TO UBOUND(dataArray)",
            "        PRINT dataArray(i)",
            "    NEXT i",
            "END SUB"
          ]
        },
        "array_boundary_checking": {
          "description": "Comprehensive example of safe array boundary checking and resizing",
          "code": [
            "'$DYNAMIC",
            "DIM SHARED inventory() AS STRING",
            "DIM SHARED itemCount AS INTEGER",
            "",
            "' Main program demonstrating safe array operations",
            "InitializeInventory",
            "AddItem \"Sword\"",
            "AddItem \"Shield\"", 
            "AddItem \"Potion\"",
            "ShowInventory",
            "ResizeInventory 10",
            "ShowInventory",
            "END",
            "",
            "SUB InitializeInventory",
            "    ' Start with empty inventory",
            "    itemCount = 0",
            "    PRINT \"Inventory system initialized\"",
            "END SUB",
            "",
            "SUB AddItem(newItem AS STRING)",
            "    ' Safely add item with automatic resizing",
            "    IF itemCount = 0 THEN",
            "        ' First item - create array",
            "        REDIM SHARED inventory(0 TO 0)",
            "    ELSE",
            "        ' Check if we need more space",
            "        IF itemCount > UBOUND(inventory) THEN",
            "            ' Grow array preserving existing data",
            "            REDIM PRESERVE SHARED inventory(LBOUND(inventory) TO itemCount)",
            "        END IF",
            "    END IF",
            "    ",
            "    ' Add the item",
            "    inventory(itemCount) = newItem",
            "    itemCount = itemCount + 1",
            "    PRINT \"Added: \"; newItem",
            "END SUB",
            "",
            "SUB ShowInventory",
            "    PRINT \"=== Inventory Status ===\"",
            "    IF itemCount = 0 THEN",
            "        PRINT \"Inventory is empty\"",
            "    ELSE",
            "        PRINT \"Items (\"; itemCount; \"):\";",
            "        PRINT \" Bounds: \"; LBOUND(inventory); \" TO \"; UBOUND(inventory)",
            "        FOR i = LBOUND(inventory) TO UBOUND(inventory)",
            "            IF i < itemCount THEN",
            "                PRINT i; \": \"; inventory(i)",
            "            ELSE",
            "                PRINT i; \": [empty slot]\"",
            "            END IF",
            "        NEXT i",
            "    END IF",
            "    PRINT",
            "END SUB",
            "",
            "SUB ResizeInventory(newSize AS INTEGER)",
            "    ' Resize inventory to specific size with bounds checking",
            "    IF newSize < 1 THEN",
            "        PRINT \"Error: Invalid inventory size\"",
            "        EXIT SUB",
            "    END IF",
            "    ",
            "    IF itemCount = 0 THEN",
            "        ' Create new array",
            "        REDIM SHARED inventory(0 TO newSize - 1)",
            "    ELSE",
            "        ' Resize existing array",
            "        REDIM PRESERVE SHARED inventory(LBOUND(inventory) TO newSize - 1)",
            "    END IF",
            "    ",
            "    ' Adjust item count if we shrunk the array",
            "    IF itemCount > newSize THEN",
            "        PRINT \"Warning: Some items were lost during resize\"",
            "        itemCount = newSize",
            "    END IF",
            "    ",
            "    PRINT \"Inventory resized to \"; newSize; \" slots\"",
            "END SUB"
          ]
        },
        "multi_dimensional_arrays": {
          "description": "Working with multi-dimensional dynamic arrays and boundary functions",
          "code": [
            "'$DYNAMIC",
            "DIM SHARED gameMap() AS INTEGER",
            "DIM SHARED mapWidth AS INTEGER, mapHeight AS INTEGER",
            "",
            "' Main program",
            "CreateMap 5, 3",
            "FillMap",
            "ShowMap",
            "ResizeMap 8, 6",
            "ShowMap",
            "END",
            "",
            "SUB CreateMap(width AS INTEGER, height AS INTEGER)",
            "    ' Create a new game map with specified dimensions",
            "    IF width < 1 OR height < 1 THEN",
            "        PRINT \"Error: Invalid map dimensions\"",
            "        EXIT SUB",
            "    END IF",
            "    ",
            "    mapWidth = width",
            "    mapHeight = height",
            "    REDIM SHARED gameMap(0 TO height - 1, 0 TO width - 1)",
            "    ",
            "    PRINT \"Created map: \"; width; \" x \"; height",
            "    PRINT \"Row bounds: \"; LBOUND(gameMap, 1); \" TO \"; UBOUND(gameMap, 1)",
            "    PRINT \"Col bounds: \"; LBOUND(gameMap, 2); \" TO \"; UBOUND(gameMap, 2)",
            "END SUB",
            "",
            "SUB FillMap",
            "    ' Fill map with sample data using boundary functions",
            "    FOR row = LBOUND(gameMap, 1) TO UBOUND(gameMap, 1)",
            "        FOR col = LBOUND(gameMap, 2) TO UBOUND(gameMap, 2)",
            "            ' Create a simple pattern",
            "            gameMap(row, col) = (row + col) MOD 3",
            "        NEXT col",
            "    NEXT row",
            "    PRINT \"Map filled with pattern data\"",
            "END SUB",
            "",
            "SUB ShowMap",
            "    ' Display the map using safe boundary checking",
            "    PRINT \"=== Current Map ===\"",
            "    FOR row = LBOUND(gameMap, 1) TO UBOUND(gameMap, 1)",
            "        FOR col = LBOUND(gameMap, 2) TO UBOUND(gameMap, 2)",
            "            PRINT gameMap(row, col);",
            "        NEXT col",
            "        PRINT",
            "    NEXT row",
            "    PRINT",
            "END SUB",
            "",
            "SUB ResizeMap(newWidth AS INTEGER, newHeight AS INTEGER)",
            "    ' Resize map - note: PRESERVE only works on last dimension",
            "    IF newWidth < 1 OR newHeight < 1 THEN",
            "        PRINT \"Error: Invalid map dimensions\"",
            "        EXIT SUB",
            "    END IF",
            "    ",
            "    PRINT \"Resizing map from \"; mapWidth; \"x\"; mapHeight;",
            "    PRINT \" to \"; newWidth; \"x\"; newHeight",
            "    ",
            "    ' For multi-dimensional arrays, PRESERVE only works on last dimension",
            "    ' So we can preserve columns but not rows",
            "    IF newHeight = mapHeight THEN",
            "        ' Same height, can preserve data in all rows",
            "        REDIM PRESERVE SHARED gameMap(0 TO newHeight - 1, 0 TO newWidth - 1)",
            "    ELSE",
            "        ' Different height, data will be lost",
            "        PRINT \"Warning: Map data will be reset due to height change\"",
            "        REDIM SHARED gameMap(0 TO newHeight - 1, 0 TO newWidth - 1)",
            "        FillMap  ' Refill with pattern",
            "    END IF",
            "    ",
            "    mapWidth = newWidth",
            "    mapHeight = newHeight",
            "END SUB"
          ]
        }
      }
    },
    "best_practices": {
      "coding_guidelines": [
        "Keep it simple: Avoid complex multi-statement lines",
        "One operation per line: Especially for declarations and assignments",
        "Use type sigils: For function return types instead of AS clauses", 
        "Initialize early: Set up arrays and variables before use",
        "Test incrementally: Build up complexity gradually",
        "Separate concerns: Split complex operations into multiple lines",
        "Use standard functions: Stick to well-documented QB64PE functions"
      ],
      "syntax_rules": [
        "Functions must use type sigils for return types, not AS clauses",
        "Console directives: $CONSOLE, $CONSOLE:ONLY (not $CONSOLE:OFF)", 
        "Avoid chaining multiple control structures on one line",
        "Array declarations should be separate when using dimensions",
        "Variable assignments should be on separate lines from declarations",
        "Some BASIC string functions may not be available (implement custom versions)"
      ]
    },
    "source_organization": {
      "title": "QB64PE Source Code Organization Requirements",
      "description": "QB64PE enforces strict ordering requirements for source code elements that cannot be violated",
      "mandatory_order": {
        "sequence": [
          "1. Types, Constants, and SHARED Variables",
          "2. Main Program Code", 
          "3. SUB and FUNCTION Definitions"
        ],
        "rules": {
          "types_first": "All TYPE definitions must appear before main program code",
          "constants_first": "All CONST declarations must appear before main program code",
          "shared_first": "All SHARED variable declarations must appear before main program code",
          "main_middle": "Main program execution code must come after declarations but before procedures",
          "procedures_last": "All SUB and FUNCTION definitions must appear after main program code"
        }
      },
      "violation_consequences": {
        "compile_errors": [
          "Duplicate definition",
          "Identifier expected",
          "SUB/FUNCTION must be defined after main module"
        ],
        "runtime_issues": [
          "Undefined variables in SHARED context",
          "Type mismatch errors",
          "Scope resolution failures"
        ]
      },
      "modular_solutions": {
        "include_system": {
          "description": "Use $INCLUDE and $INCLUDEONCE to organize code in separate files",
          "file_conventions": {
            ".BI": "BASIC Include files - contains TYPE definitions, CONST declarations, SHARED variables, and SUB/FUNCTION declarations",
            ".BM": "BASIC Module files - contains SUB and FUNCTION implementations"
          },
          "include_directives": {
            "$INCLUDE": "Include file contents at compile time (can include multiple times)",
            "$INCLUDEONCE": "Include file contents only once, even if referenced multiple times"
          }
        },
        "library_pattern": {
          "master_include": {
            "purpose": "Single include file that brings in entire library",
            "example": "_GJ_LIB.BI includes all library components with $INCLUDEONCE",
            "benefits": ["Unified testing", "Simplified usage", "Dependency management"]
          },
          "modular_includes": {
            "purpose": "Individual library components can be included separately",
            "pattern": "LibraryName.BI + LibraryName.BM file pairs",
            "example": "ANSI.BI (declarations) + ANSI.BM (implementations)"
          },
          "common_definitions": {
            "purpose": "Shared constants and cross-platform compatibility",
            "example": "_GJ_LIB_COMMON.BI with conditional compilation for different platforms",
            "usage": "Included by other .BI files to ensure consistent definitions"
          }
        }
      },
      "real_world_example": {
        "repository": "QB64_GJ_LIB",
        "structure": {
          "master_file": "_GJ_LIB.BI - Uses $INCLUDEONCE to include all library components",
          "common_file": "_GJ_LIB_COMMON.BI - Cross-platform constants and compatibility definitions",
          "library_pairs": [
            "ANSI/ANSI.BI + ANSI/ANSI.BM - ANSI terminal support",
            "Each library follows .BI (declarations) + .BM (implementations) pattern"
          ]
        },
        "organization_example": {
          "ansi_bi_structure": [
            "' Documentation and usage notes",
            "$INCLUDEONCE '_GJ_LIB_COMMON.BI' - Common definitions first",
            "TYPE definitions for ANSI structures",
            "CONST declarations for ANSI codes and colors", 
            "SHARED variable declarations",
            "SUB and FUNCTION declarations (headers only)"
          ],
          "ansi_bm_structure": [
            "' Documentation and implementation notes",
            "' Full SUB and FUNCTION implementations",
            "' All procedures defined after main program space"
          ]
        }
      },
      "best_practices": {
        "file_organization": [
          "Use descriptive comments at the top explaining the library's purpose",
          "Group related TYPE definitions together",
          "Group related CONST definitions together",
          "Declare SHARED variables that will be used across modules",
          "Include proper $INCLUDEONCE directives to prevent duplicate inclusions"
        ],
        "include_strategies": [
          "Create master include files for complete libraries",
          "Use individual include files for modular functionality",
          "Establish clear dependencies between include files",
          "Document the proper inclusion order in comments"
        ],
        "cross_platform": [
          "Use conditional compilation for platform-specific code",
          "Define platform constants in common include files",
          "Test on all target platforms to ensure compatibility",
          "Document platform limitations in comments"
        ]
      },
      "examples": {
        "wrong_organization": {
          "description": "This will cause compile errors in QB64PE",
          "code": [
            "' This violates QB64PE ordering rules",
            "PRINT \"Hello World\"  ' Main program code",
            "",
            "TYPE Point             ' ERROR: TYPE after main code",
            "    x AS INTEGER",
            "    y AS INTEGER", 
            "END TYPE",
            "",
            "SUB ShowPoint(p AS Point)  ' SUB definition",
            "    PRINT p.x, p.y",
            "END SUB"
          ]
        },
        "correct_organization": {
          "description": "Proper QB64PE source organization",
          "code": [
            "' Types and constants first",
            "TYPE Point",
            "    x AS INTEGER",
            "    y AS INTEGER",
            "END TYPE",
            "",
            "' Main program code", 
            "DIM p AS Point",
            "p.x = 10: p.y = 20",
            "ShowPoint p",
            "END",
            "",
            "' SUB and FUNCTION definitions last",
            "SUB ShowPoint(pt AS Point)",
            "    PRINT pt.x, pt.y",
            "END SUB"
          ]
        },
        "modular_solution": {
          "description": "Using include files to overcome ordering restrictions",
          "files": {
            "main.bas": [
              "$INCLUDEONCE 'types.bi'    ' Include types and constants",
              "$INCLUDEONCE 'procedures.bi' ' Include procedure declarations",
              "",
              "' Main program code",
              "DIM p AS Point",
              "p.x = 10: p.y = 20", 
              "ShowPoint p",
              "",
              "$INCLUDE 'procedures.bm'    ' Include procedure implementations"
            ],
            "types.bi": [
              "' Type and constant definitions",
              "TYPE Point",
              "    x AS INTEGER",
              "    y AS INTEGER",
              "END TYPE"
            ],
            "procedures.bi": [
              "' Procedure declarations only", 
              "DECLARE SUB ShowPoint(pt AS Point)"
            ],
            "procedures.bm": [
              "' Procedure implementations",
              "SUB ShowPoint(pt AS Point)",
              "    PRINT pt.x, pt.y",
              "END SUB"
            ]
          }
        }
      }
    },
    "validation_checklist": [
      "Function declarations using AS clauses instead of sigils",
      "Invalid console directives ($CONSOLE:OFF)",
      "Multiple IF statements on one line with colons",
      "Multiple array declarations with dimensions on one line",
      "Complex multi-statement lines with declarations", 
      "Usage of non-existent string functions (_WORD$, etc.)",
      "Uninitialized SHARED arrays in included modules",
      "Legacy BASIC keywords (DEF FN, TRON, TROFF, etc.)",
      "Device access statements (OPEN LPT:, PEN, etc.)",
      "Platform-specific functions on wrong platforms", 
      "Hardware access functions (SETMEM, SIGNAL, etc.)",
      "Unsupported PRINT combinations (WIDTH LPRINT)",
      "TYPE definitions appearing after main program code",
      "CONST declarations appearing after main program code",
      "SHARED variables declared after main program code",
      "SUB/FUNCTION definitions appearing before main program code",
      "Missing $INCLUDEONCE directives in modular code",
      "Improper include file organization (.BI/.BM pattern violations)",
      "Variables accessed in SUB/FUNCTION without proper SHARED declaration",
      "Dynamic arrays without $DYNAMIC directive",
      "SHARED keyword used without DIM statement", 
      "Local variables shadowing SHARED variables with same names",
      "Arrays not properly shared between procedures",
      "Missing SHARED declarations for global variable access in procedures",
      "REDIM used on static arrays (declared with fixed dimensions)",
      "REDIM operations without proper $DYNAMIC directive",
      "Array access with hardcoded indices instead of boundary functions",
      "Loop iterations using hardcoded bounds instead of UBOUND/LBOUND",
      "REDIM PRESERVE used on non-last dimension of multi-dimensional arrays",
      "Array access without boundary validation using UBOUND/LBOUND",
      "Missing error handling around REDIM operations",
      "REDIM SHARED used in procedures without considering global impact",
      "Dynamic arrays not properly initialized before REDIM operations",
      "Array boundary checking missing in user input validation",
      "Inconsistent array indexing patterns (mixing 0-based and 1-based)",
      "Memory management issues with large dynamic arrays"
    ],
    "array_management": {
      "title": "Comprehensive Array Management in QB64PE",
      "description": "Complete guide to array declaration, resizing, boundary checking, and safe array operations",
      "array_types": {
        "static_arrays": {
          "title": "Static Arrays",
          "description": "Arrays with fixed size determined at compile time",
          "characteristics": [
            "Size cannot be changed during program execution",
            "Faster memory access than dynamic arrays",
            "Memory allocated at compile time",
            "Default array type in QB64PE"
          ],
          "declaration_syntax": [
            "DIM arrayName(size) AS dataType",
            "DIM arrayName(lowerBound TO upperBound) AS dataType",
            "DIM arrayName(rows, cols) AS dataType ' Multi-dimensional"
          ],
          "examples": [
            "DIM scores(100) AS INTEGER ' 0 to 100 (101 elements)",
            "DIM grades(1 TO 10) AS SINGLE ' 1 to 10 (10 elements)",
            "DIM matrix(0 TO 9, 0 TO 9) AS DOUBLE ' 10x10 matrix"
          ]
        },
        "dynamic_arrays": {
          "title": "Dynamic Arrays",
          "description": "Arrays that can be resized during program execution",
          "requirements": [
            "$DYNAMIC directive must be used",
            "Arrays must be declared with empty parentheses",
            "REDIM statement used to allocate/resize"
          ],
          "declaration_syntax": [
            "'$DYNAMIC",
            "DIM arrayName() AS dataType",
            "REDIM arrayName(newSize) AS dataType"
          ],
          "advantages": [
            "Size can change based on runtime conditions",
            "Memory efficient for variable-sized data",
            "Supports data growth and shrinkage"
          ],
          "disadvantages": [
            "Slightly slower access than static arrays",
            "Additional memory management overhead",
            "Potential for memory fragmentation"
          ]
        }
      },
      "redim_operations": {
        "basic_redim": {
          "syntax": "REDIM arrayName(newDimensions) AS dataType",
          "behavior": [
            "Destroys all existing array content",
            "Allocates new memory with specified dimensions",
            "Initializes all elements to zero/empty",
            "Can change any dimension of multi-dimensional arrays"
          ],
          "use_cases": [
            "Initial allocation of dynamic arrays",
            "Complete resize when data preservation not needed",
            "Changing array structure significantly"
          ]
        },
        "preserve_redim": {
          "syntax": "REDIM PRESERVE arrayName(newDimensions) AS dataType",
          "behavior": [
            "Preserves existing data that fits in new dimensions",
            "Only allows resizing the last dimension in multi-dimensional arrays",
            "New elements initialized to zero/empty",
            "Slower than basic REDIM due to data copying"
          ],
          "limitations": [
            "Multi-dimensional arrays: only last dimension can be resized",
            "Cannot change the number of dimensions",
            "Cannot change the data type",
            "Performance impact on large arrays"
          ],
          "use_cases": [
            "Growing arrays while keeping existing data",
            "Expanding the last dimension of multi-dimensional arrays",
            "Adding elements to existing collections"
          ]
        },
        "shared_redim": {
          "syntax": "REDIM SHARED arrayName(newDimensions) AS dataType",
          "behavior": [
            "Creates or resizes a global array",
            "Array becomes accessible from all procedures",
            "Can be called from within SUB/FUNCTION",
            "Combines REDIM functionality with SHARED scope"
          ],
          "considerations": [
            "Affects global state from within procedures",
            "Should be used carefully to avoid unexpected side effects",
            "Useful for creating global arrays at runtime",
            "Can be combined with PRESERVE: REDIM PRESERVE SHARED"
          ]
        }
      },
      "boundary_functions": {
        "ubound_function": {
          "purpose": "Returns the upper boundary (maximum valid index) of an array dimension",
          "syntax": [
            "upperBound = UBOUND(arrayName) ' Single dimension",
            "upperBound = UBOUND(arrayName, dimensionNumber) ' Specific dimension"
          ],
          "behavior": [
            "Returns highest valid index for the specified dimension",
            "Dimension numbering starts from 1 (first dimension = 1)",
            "Works with both static and dynamic arrays",
            "Essential for safe array iteration and bounds checking"
          ],
          "common_usage": [
            "FOR i = 0 TO UBOUND(array): ... : NEXT i",
            "FOR i = LBOUND(array) TO UBOUND(array): ... : NEXT i",
            "IF index <= UBOUND(array) THEN array(index) = value"
          ]
        },
        "lbound_function": {
          "purpose": "Returns the lower boundary (minimum valid index) of an array dimension",
          "syntax": [
            "lowerBound = LBOUND(arrayName) ' Single dimension", 
            "lowerBound = LBOUND(arrayName, dimensionNumber) ' Specific dimension"
          ],
          "behavior": [
            "Returns lowest valid index for the specified dimension",
            "Usually 0 for QB64PE arrays unless TO keyword used",
            "Dimension numbering starts from 1 (first dimension = 1)",
            "Important for arrays with custom lower bounds"
          ],
          "default_values": [
            "DIM array(10): LBOUND = 0, UBOUND = 10",
            "DIM array(5 TO 15): LBOUND = 5, UBOUND = 15",
            "DIM array(-10 TO 10): LBOUND = -10, UBOUND = 10"
          ]
        },
        "multi_dimensional_bounds": {
          "description": "Working with boundaries in multi-dimensional arrays",
          "syntax_examples": [
            "rows = UBOUND(matrix, 1) - LBOUND(matrix, 1) + 1",
            "cols = UBOUND(matrix, 2) - LBOUND(matrix, 2) + 1",
            "FOR r = LBOUND(matrix, 1) TO UBOUND(matrix, 1)",
            "    FOR c = LBOUND(matrix, 2) TO UBOUND(matrix, 2)",
            "        ' Safe access to matrix(r, c)",
            "    NEXT c",
            "NEXT r"
          ],
          "best_practices": [
            "Always specify dimension number for multi-dimensional arrays",
            "Store boundary values in variables for repeated use",
            "Use boundary functions in all loop conditions",
            "Validate indices before array access"
          ]
        }
      },
      "safe_array_practices": {
        "boundary_validation": {
          "description": "Always validate array indices before access",
          "techniques": [
            "Check indices against LBOUND and UBOUND before access",
            "Use boundary functions in loop conditions",
            "Implement bounds checking functions for reusability",
            "Validate user input before using as array index"
          ],
          "example_patterns": [
            "IF index >= LBOUND(array) AND index <= UBOUND(array) THEN",
            "    array(index) = value",
            "ELSE",
            "    PRINT \"Index out of bounds\"",
            "END IF"
          ]
        },
        "safe_iteration": {
          "description": "Use boundary functions for all array loops",
          "recommended_patterns": [
            "FOR i = LBOUND(array) TO UBOUND(array)",
            "FOR row = LBOUND(matrix, 1) TO UBOUND(matrix, 1)",
            "    FOR col = LBOUND(matrix, 2) TO UBOUND(matrix, 2)"
          ],
          "avoid_patterns": [
            "FOR i = 0 TO 100 ' Hardcoded upper bound",
            "FOR i = 1 TO arraySize ' Variable that may not match actual size"
          ]
        },
        "resize_strategies": {
          "growth_patterns": [
            "Exponential growth: newSize = oldSize * 2",
            "Linear growth: newSize = oldSize + increment",
            "Exact fit: newSize = requiredElements",
            "Block allocation: newSize = ((required / blockSize) + 1) * blockSize"
          ],
          "performance_considerations": [
            "Minimize resize operations for better performance",
            "Use REDIM PRESERVE only when data must be kept",
            "Consider memory usage with large arrays",
            "Plan for typical data sizes to reduce resizing"
          ]
        },
        "error_handling": {
          "description": "Robust error handling for array operations",
          "common_errors": [
            "Subscript out of range (accessing invalid index)",
            "Array not defined (using unallocated dynamic array)",
            "Type mismatch (wrong data type for array element)",
            "Memory allocation failure (insufficient memory for large arrays)"
          ],
          "prevention_techniques": [
            "Always check array allocation before use",
            "Validate all indices before array access",
            "Use error trapping around REDIM operations",
            "Implement defensive programming practices"
          ]
        }
      },
      "advanced_techniques": {
        "conditional_allocation": {
          "description": "Allocate arrays only when needed",
          "pattern": [
            "' Check if array needs to be allocated",
            "IF UBOUND(array) < LBOUND(array) THEN",
            "    ' Array not allocated yet",
            "    REDIM array(initialSize)",
            "END IF"
          ]
        },
        "capacity_management": {
          "description": "Manage array capacity efficiently",
          "pattern": [
            "SUB EnsureCapacity(array() AS INTEGER, requiredSize AS INTEGER)",
            "    DIM currentCapacity AS INTEGER",
            "    currentCapacity = UBOUND(array) - LBOUND(array) + 1",
            "    IF currentCapacity < requiredSize THEN",
            "        REDIM PRESERVE array(LBOUND(array) TO LBOUND(array) + requiredSize - 1)",
            "    END IF",
            "END SUB"
          ]
        },
        "multi_dimensional_resize": {
          "description": "Strategies for resizing multi-dimensional arrays",
          "preserve_limitation": [
            "REDIM PRESERVE only works on the last dimension",
            "To resize other dimensions, must use REDIM (loses data)",
            "Consider array design with resizable dimension last"
          ],
          "workaround_strategies": [
            "Manually copy data to new array when resizing non-last dimensions",
            "Use array of arrays for more flexible resizing",
            "Design data structures with growth dimension last"
          ]
        }
      },
      "common_pitfalls": {
        "static_array_redim": {
          "problem": "Attempting to REDIM a static array",
          "error": "Array already dimensioned",
          "solution": "Declare dynamic arrays with empty parentheses: DIM array()"
        },
        "preserve_wrong_dimension": {
          "problem": "Using REDIM PRESERVE on non-last dimension",
          "error": "Can't REDIM PRESERVE that dimension",
          "solution": "Only resize the last dimension with PRESERVE, or use regular REDIM"
        },
        "missing_dynamic_directive": {
          "problem": "Using REDIM without $DYNAMIC directive",
          "error": "Array not defined or subscript out of range",
          "solution": "Add '$DYNAMIC before dynamic array declarations"
        },
        "hardcoded_bounds": {
          "problem": "Using hardcoded array bounds in loops",
          "issue": "Code breaks when array size changes",
          "solution": "Always use LBOUND and UBOUND functions"
        },
        "uninitialized_access": {
          "problem": "Accessing dynamic array before allocation",
          "error": "Subscript out of range",
          "solution": "Check array allocation or use error handling"
        }
      },
      "performance_guidelines": {
        "memory_efficiency": [
          "Use static arrays when size is known and fixed",
          "Minimize REDIM operations in performance-critical code",
          "Consider memory usage patterns with large arrays",
          "Free unused array memory when possible"
        ],
        "access_patterns": [
          "Sequential access is faster than random access",
          "Locality of reference improves cache performance",
          "Minimize array copying in REDIM PRESERVE operations",
          "Use appropriate data types to optimize memory usage"
        ],
        "optimization_tips": [
          "Pre-allocate arrays to expected maximum size when possible",
          "Use exponential growth strategies for dynamic arrays",
          "Batch array operations when feasible",
          "Profile memory usage with large datasets"
        ]
      }
    },
    "debugging": {
      "error_handling": {
        "traditional": {
          "keywords": ["ON ERROR GOTO", "ERR", "RESUME", "RESUME NEXT", "_ERRORLINE"],
          "description": "Classic BASIC error handling with error codes and resume options"
        },
        "modern_assertions": {
          "keywords": ["$ASSERTS:CONSOLE", "$ASSERTS:OFF", "_ASSERT"],
          "description": "Modern assertion-based debugging for development testing"
        },
        "console_debugging": {
          "keywords": ["$CONSOLE", "$CONSOLE:ONLY", "_DEST _CONSOLE", "_DEST 0"],
          "description": "Console window alongside graphics for debugging output"
        },
        "logging_system": {
          "keywords": ["_LOGERROR", "_LOGWARN", "_LOGINFO", "_LOGTRACE"],
          "description": "Built-in logging system (QB64PE v4.0.0+) with timestamps and stack traces"
        }
      },
      "common_error_codes": {
        "52": "Bad file name or number",
        "53": "File not found", 
        "55": "File already open",
        "62": "Input past end of file",
        "64": "Bad file name",
        "70": "Permission denied",
        "75": "Path/File access error",
        "76": "Path not found"
      }
    }
  },
  "patterns": {
    "function_return_type_as_clause": {
      "regex": "FUNCTION\\s+(\\w+)\\s*\\([^)]*\\)\\s+AS\\s+(\\w+)",
      "severity": "error",
      "message": "Function return types must use type sigils, not AS clauses",
      "suggestion": "Use FUNCTION {name}{sigil}({params}) instead of FUNCTION {name}({params}) AS {type}"
    },
    "console_off_directive": {
      "regex": "\\$CONSOLE\\s*:\\s*OFF",
      "severity": "error", 
      "message": "$CONSOLE:OFF is not valid syntax",
      "suggestion": "Use $CONSOLE or $CONSOLE:ONLY instead"
    },
    "chained_if_statements": {
      "regex": "IF\\s+[^\\n]+\\s+THEN\\s+[^\\n]+:\\s*IF\\s+[^\\n]+\\s+THEN",
      "severity": "warning",
      "message": "Chained IF statements on one line can cause parsing errors",
      "suggestion": "Split IF statements onto separate lines"
    },
    "multi_array_declaration": {
      "regex": "DIM\\s+\\w+\\s*\\([^)]+\\)\\s+AS\\s+\\w+\\s*,\\s*\\w+\\s*\\([^)]+\\)\\s+AS\\s+\\w+",
      "severity": "error",
      "message": "Multiple array declarations with dimensions on one line not supported", 
      "suggestion": "Declare each array on a separate line"
    },
    "missing_string_functions": {
      "regex": "\\b(_WORD\\$|_TRIM\\$)\\b",
      "severity": "error",
      "message": "Function does not exist in QB64PE",
      "suggestion": "Use built-in string functions like INSTR, MID$, LEFT$, RIGHT$ instead"
    },
    "legacy_keywords": {
      "regex": "\\b(DEF\\s+FN|TRON|TROFF|SETMEM|SIGNAL)\\b",
      "severity": "error",
      "message": "Legacy BASIC keyword not supported in QB64PE",
      "suggestion": "Use modern QB64PE alternatives"
    },
    "device_access": {
      "regex": "\\b(ON\\s+PEN|PEN\\s+ON|PEN\\s+OFF|ON\\s+UEVENT)\\b",
      "severity": "error",
      "message": "Device access keyword not supported in QB64PE",
      "suggestion": "Use modern QB64PE input/output methods"
    },
    "type_after_main": {
      "regex": "(?:PRINT|INPUT|FOR|WHILE|IF|DO|_|SCREEN|PSET|LINE|CIRCLE)[\\s\\S]*?TYPE\\s+\\w+",
      "severity": "error",
      "message": "TYPE definition found after main program code",
      "suggestion": "Move all TYPE definitions to the beginning of the file or use $INCLUDE files"
    },
    "const_after_main": {
      "regex": "(?:PRINT|INPUT|FOR|WHILE|IF|DO|_|SCREEN|PSET|LINE|CIRCLE)[\\s\\S]*?CONST\\s+\\w+",
      "severity": "error", 
      "message": "CONST declaration found after main program code",
      "suggestion": "Move all CONST declarations to the beginning of the file or use $INCLUDE files"
    },
    "sub_function_before_main": {
      "regex": "^\\s*(?:SUB|FUNCTION)\\s+\\w+[\\s\\S]*?(?:PRINT|INPUT|FOR|WHILE|IF|DO|_|SCREEN|PSET|LINE|CIRCLE)",
      "severity": "warning",
      "message": "SUB/FUNCTION definition found before main program code",
      "suggestion": "Move SUB/FUNCTION definitions after main program code or use modular includes"
    },
    "missing_includeonce": {
      "regex": "\\$INCLUDE\\s+['\"].*\\.bi['\"]",
      "severity": "info",
      "message": "Consider using $INCLUDEONCE instead of $INCLUDE for .BI files",
      "suggestion": "Use $INCLUDEONCE to prevent duplicate inclusions"
    },
    "variable_scope_access": {
      "regex": "(?:SUB|FUNCTION)\\s+\\w+[\\s\\S]*?\\w+\\s*=\\s*\\w+[\\s\\S]*?(?=END\\s+(?:SUB|FUNCTION))",
      "severity": "warning",
      "message": "Potential variable scope issue - accessing variables that may not be in scope",
      "suggestion": "Use DIM SHARED for variables that need to be accessed across SUB/FUNCTION boundaries"
    },
    "missing_dynamic_directive": {
      "regex": "DIM\\s+\\w+\\s*\\(\\s*[a-zA-Z]\\w*\\s*(?:TO\\s+[a-zA-Z]\\w*)?\\s*\\)\\s+AS",
      "severity": "warning",
      "message": "Dynamic array without $DYNAMIC directive may cause issues",
      "suggestion": "Add '$DYNAMIC or use static array bounds with constants"
    },
    "shared_without_dim": {
      "regex": "SHARED\\s+(?!.*DIM)\\w+",
      "severity": "error",
      "message": "SHARED keyword must be used with DIM statement",
      "suggestion": "Use 'DIM SHARED variableName AS type' instead of 'SHARED variableName'"
    },
    "local_variable_shadow": {
      "regex": "(?:SUB|FUNCTION)\\s+\\w+[\\s\\S]*?DIM\\s+(?!SHARED)\\w+[\\s\\S]*?(?=\\bEND\\s+(?:SUB|FUNCTION))",
      "severity": "info",
      "message": "Local variable may shadow a SHARED variable with the same name",
      "suggestion": "Use unique variable names in local scope or explicitly reference SHARED variables"
    },
    "redim_static_array": {
      "regex": "DIM\\s+(\\w+)\\s*\\(\\s*\\d+\\s*(?:TO\\s+\\d+)?\\s*\\)[\\s\\S]*?REDIM\\s+\\1",
      "severity": "error",
      "message": "Cannot REDIM a static array (declared with fixed dimensions)",
      "suggestion": "Declare array with empty dimensions DIM arrayName() for dynamic resizing"
    },
    "redim_without_dynamic": {
      "regex": "(?!.*\\$DYNAMIC)[\\s\\S]*REDIM\\s+\\w+",
      "severity": "warning",
      "message": "REDIM used without $DYNAMIC directive",
      "suggestion": "Add '$DYNAMIC directive before array declarations that will be resized"
    },
    "unsafe_array_access": {
      "regex": "\\w+\\s*\\(\\s*\\d+\\s*\\)\\s*=",
      "severity": "info",
      "message": "Hardcoded array index may be unsafe",
      "suggestion": "Use UBOUND/LBOUND functions to ensure array bounds are respected"
    },
    "loop_without_bounds": {
      "regex": "FOR\\s+\\w+\\s*=\\s*\\d+\\s+TO\\s+\\d+[\\s\\S]*?\\w+\\s*\\([\\s\\S]*?\\)",
      "severity": "warning",
      "message": "Array access in loop with hardcoded bounds",
      "suggestion": "Use LBOUND and UBOUND functions for safe array iteration"
    },
    "redim_preserve_multi_dim": {
      "regex": "REDIM\\s+PRESERVE\\s+\\w+\\s*\\([^,]*,[^,]*,",
      "severity": "error",
      "message": "REDIM PRESERVE can only resize the last dimension of multi-dimensional arrays",
      "suggestion": "Only resize the rightmost dimension when using PRESERVE with multi-dimensional arrays"
    },
    "missing_boundary_check": {
      "regex": "\\w+\\s*\\(\\s*[a-zA-Z]\\w*\\s*\\)\\s*=",
      "severity": "info",
      "message": "Array access with variable index without boundary checking",
      "suggestion": "Validate index against LBOUND and UBOUND before array access"
    },
    "redim_shared_in_procedure": {
      "regex": "(?:SUB|FUNCTION)\\s+\\w+[\\s\\S]*?REDIM\\s+SHARED\\s+\\w+",
      "severity": "info",
      "message": "REDIM SHARED used within procedure affects global array",
      "suggestion": "Consider if global array modification is intended or use local array instead"
    }
  },
  "variable_types": {
    "description": "Comprehensive information about QB64PE variable types, sigils, memory sizes, and conventions",
    "type_definitions": {
      "basic_types": {
        "STRING": {
          "sigil": "$",
          "size": "variable",
          "memory_bytes": "length + overhead",
          "range": "ASCII 0-255 characters",
          "example": "name$",
          "usage": "Text and character data"
        },
        "INTEGER": {
          "sigil": "%",
          "size": "2 bytes",
          "memory_bytes": 2,
          "range": "-32,768 to 32,767",
          "example": "count%",
          "usage": "Small whole numbers"
        },
        "LONG": {
          "sigil": "&",
          "size": "4 bytes", 
          "memory_bytes": 4,
          "range": "-2,147,483,648 to 2,147,483,647",
          "example": "bigNum&",
          "usage": "Standard integer calculations"
        },
        "SINGLE": {
          "sigil": "!",
          "size": "4 bytes",
          "memory_bytes": 4,
          "range": "±3.4E±38 (7 digits precision)",
          "example": "price!",
          "usage": "Floating-point calculations"
        },
        "DOUBLE": {
          "sigil": "#",
          "size": "8 bytes",
          "memory_bytes": 8,
          "range": "±1.7E±308 (15 digits precision)",
          "example": "precise#",
          "usage": "High-precision calculations"
        }
      },
      "qb64_types": {
        "_FLOAT": {
          "sigil": "##",
          "size": "32 bytes",
          "memory_bytes": 32,
          "range": "Maximum floating-point precision",
          "example": "maxFloat##",
          "usage": "Extreme precision calculations"
        },
        "_INTEGER64": {
          "sigil": "&&",
          "size": "8 bytes",
          "memory_bytes": 8,
          "range": "-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807",
          "example": "huge&&",
          "usage": "Very large integer values"
        },
        "_BYTE": {
          "sigil": "%%",
          "size": "1 byte",
          "memory_bytes": 1,
          "range": "-128 to 127",
          "example": "small%%",
          "usage": "Small values, memory optimization"
        },
        "_BIT": {
          "sigil": "`",
          "size": "1 bit",
          "memory_bytes": 0.125,
          "range": "0 or -1 (signed), 0 or 1 (unsigned)",
          "example": "flag`",
          "usage": "Boolean flags and bit operations"
        },
        "_OFFSET": {
          "sigil": "%&",
          "size": "platform-dependent",
          "memory_bytes": "4 or 8",
          "range": "Memory address pointer",
          "example": "address%&",
          "usage": "Memory operations and pointers"
        },
        "_MEM": {
          "sigil": "none",
          "size": "structure",
          "memory_bytes": "fixed structure size",
          "range": "Contains OFFSET, SIZE, TYPE, ELEMENTSIZE",
          "example": "memBlock AS _MEM",
          "usage": "Memory block operations"
        }
      },
      "unsigned_types": {
        "description": "All numeric types can be made unsigned using ~ prefix or _UNSIGNED keyword",
        "convention": "~ before sigil or _UNSIGNED AS keyword",
        "examples": {
          "_UNSIGNED INTEGER": {
            "sigil_form": "~%",
            "keyword_form": "AS _UNSIGNED INTEGER",
            "range": "0 to 65,535",
            "memory_bytes": 2
          },
          "_UNSIGNED LONG": {
            "sigil_form": "~&",
            "keyword_form": "AS _UNSIGNED LONG",
            "range": "0 to 4,294,967,295",
            "memory_bytes": 4
          },
          "_UNSIGNED _BYTE": {
            "sigil_form": "~%%",
            "keyword_form": "AS _UNSIGNED _BYTE",
            "range": "0 to 255",
            "memory_bytes": 1
          },
          "_UNSIGNED _BIT": {
            "sigil_form": "~`",
            "keyword_form": "AS _UNSIGNED _BIT",
            "range": "0 or 1",
            "memory_bytes": 0.125
          },
          "_UNSIGNED _INTEGER64": {
            "sigil_form": "~&&",
            "keyword_form": "AS _UNSIGNED _INTEGER64",
            "range": "0 to 18,446,744,073,709,551,615",
            "memory_bytes": 8
          },
          "_UNSIGNED _OFFSET": {
            "sigil_form": "~%&",
            "keyword_form": "AS _UNSIGNED _OFFSET",
            "range": "Positive memory addresses only",
            "memory_bytes": "4 or 8"
          }
        }
      }
    },
    "dim_patterns": {
      "basic_syntax": "DIM variable AS type",
      "multi_variable": "DIM AS type var1, var2, var3",
      "mixed_types": "DIM AS type1 var1, AS type2 var2",
      "arrays": {
        "static": "DIM array(size) AS type",
        "dynamic": "DIM array() AS type",
        "multi_dimensional": "DIM array(x, y, z) AS type",
        "with_bounds": "DIM array(0 TO 10) AS type"
      },
      "fixed_length_strings": "DIM variable AS STRING * length",
      "examples": [
        "DIM AS INTEGER foo, bar, baz",
        "DIM AS LONG count, total, sum",
        "DIM AS DOUBLE x, y, z",
        "DIM AS STRING name, address, city",
        "DIM AS _UNSIGNED INTEGER width, height",
        "DIM AS _UNSIGNED LONG largeNumber",
        "DIM numbers(10) AS INTEGER",
        "DIM names(100) AS STRING * 50"
      ]
    },
    "memory_optimization": {
      "type_selection_guidelines": {
        "counters_indices": "Use _UNSIGNED INTEGER or _UNSIGNED LONG",
        "small_values": "Use _BYTE or _UNSIGNED _BYTE",
        "flags_boolean": "Use _BIT or _UNSIGNED _BIT",
        "standard_math": "Use LONG or SINGLE",
        "precision_math": "Use DOUBLE or _FLOAT",
        "large_integers": "Use _INTEGER64 or _UNSIGNED _INTEGER64",
        "memory_addresses": "Use _OFFSET or _UNSIGNED _OFFSET"
      },
      "array_considerations": {
        "element_size_impact": "Smaller types reduce memory usage significantly",
        "cache_performance": "Smaller types improve cache locality",
        "examples": {
          "_BYTE array(1000)": "1,000 bytes",
          "INTEGER array(1000)": "2,000 bytes",
          "LONG array(1000)": "4,000 bytes",
          "DOUBLE array(1000)": "8,000 bytes",
          "_FLOAT array(1000)": "32,000 bytes"
        }
      }
    },
    "default_type_commands": {
      "legacy_qbasic": {
        "DEFINT": "Set default type to INTEGER for variable name ranges",
        "DEFSNG": "Set default type to SINGLE for variable name ranges", 
        "DEFDBL": "Set default type to DOUBLE for variable name ranges",
        "DEFSTR": "Set default type to STRING for variable name ranges",
        "DEFLNG": "Set default type to LONG for variable name ranges"
      },
      "qb64pe_modern": {
        "_DEFINE": "Modern command supporting all QB64PE types including unsigned",
        "examples": [
          "_DEFINE A-M AS INTEGER",
          "_DEFINE N-Z AS DOUBLE",
          "_DEFINE U AS _UNSIGNED LONG",
          "_DEFINE S AS STRING"
        ]
      }
    },
    "type_compatibility": {
      "automatic_promotion": "Smaller types automatically promote to larger types",
      "casting_functions": [
        "CINT() - Convert to INTEGER",
        "CLNG() - Convert to LONG", 
        "CSNG() - Convert to SINGLE",
        "CDBL() - Convert to DOUBLE"
      ],
      "special_rules": {
        "_MEM_OFFSET_no_casting": "_MEM and _OFFSET types cannot be cast to other types",
        "unsigned_overflow": "Unsigned types require careful handling to avoid overflow",
        "precision_loss": "Converting floating-point to integer loses fractional part"
      }
    },
    "performance_characteristics": {
      "fastest_types": ["_BYTE", "_UNSIGNED _BYTE", "INTEGER", "_UNSIGNED INTEGER"],
      "standard_types": ["LONG", "_UNSIGNED LONG", "SINGLE"],
      "precision_types": ["DOUBLE", "_INTEGER64", "_UNSIGNED _INTEGER64"],
      "slowest_types": ["_FLOAT"],
      "memory_efficient": ["_BIT", "_BYTE", "INTEGER"],
      "space_vs_speed": "Smaller types save memory but may be slower on some operations"
    }
  }
}
