# parse_qb64pe_structured_output

**Category**: Output Processing & Analysis  
**Description**: Parse structured output from QB64PE programs enhanced with native logging and organized sections  
**Type**: Output Analysis Tool  

## Overview

The `parse_qb64pe_structured_output` tool analyzes and parses structured output generated by QB64PE programs that have been enhanced with native logging, ECHO functions, and organized debug sections. This tool is essential for automated systems, LLMs, and developers who need to extract meaningful information from QB64PE program execution output.

The tool recognizes structured sections, extracts debug information, categorizes log messages, and provides analysis of program execution flow. It's particularly valuable for automated testing, debugging workflows, and AI-assisted development where programmatic analysis of QB64PE output is required.

## Purpose

This tool serves multiple critical functions in QB64PE development:

- **Output Analysis**: Parse and analyze structured QB64PE program output
- **Information Extraction**: Extract debug information, errors, and execution data
- **Automation Support**: Provide parseable data for automated systems
- **Error Detection**: Identify and categorize errors and warnings
- **Performance Analysis**: Extract timing and resource usage information

## Parameters

### Required Parameters

**output** (string)  
Raw output from QB64PE program execution that contains structured sections and logging information. Can include:
- Console output from programs using ECHO functions
- Structured debug sections with section delimiters
- Native logging output with timestamps and severity levels
- Error messages and execution status information

## Response Structure

The tool returns a comprehensive analysis of the structured output:

```json
{
  "parseSuccessful": true,
  "outputType": "structured",
  "totalLines": 156,
  "sectionsFound": 5,
  "sections": {
    "EXECUTION_SUMMARY": {
      "content": ["Program: Graphics Demo", "Start time: 2024-01-15 10:30:00"],
      "lineCount": 8,
      "startLine": 1,
      "endLine": 8
    },
    "DEBUG_INFO": {
      "content": ["INFO: Graphics initialized", "INFO: Loading resources"],
      "lineCount": 12,
      "startLine": 9,
      "endLine": 20
    },
    "ERROR_LOG": {
      "content": ["WARN: Resource low", "ERROR: File not found"],
      "lineCount": 3,
      "startLine": 21,
      "endLine": 23
    }
  },
  "logMessages": [
    {
      "level": "INFO",
      "message": "Graphics initialized",
      "timestamp": "10:30:01",
      "section": "DEBUG_INFO",
      "line": 9
    },
    {
      "level": "ERROR", 
      "message": "File not found",
      "timestamp": "10:30:15",
      "section": "ERROR_LOG",
      "line": 23
    }
  ],
  "executionStatus": {
    "completed": true,
    "timedOut": false,
    "crashed": false,
    "exitCode": 0,
    "duration": "14.5 seconds"
  },
  "errors": [
    {
      "type": "file_error",
      "severity": "high",
      "message": "File not found",
      "line": 23,
      "section": "ERROR_LOG"
    }
  ],
  "warnings": [
    {
      "type": "resource_warning",
      "severity": "medium",
      "message": "Resource low",
      "line": 21,
      "section": "ERROR_LOG"
    }
  ],
  "performance": {
    "executionTime": 14.5,
    "resourceUsage": "memory: 45MB, handles: 8",
    "bottlenecks": ["File I/O operations"]
  },
  "summary": {
    "totalErrors": 1,
    "totalWarnings": 1,
    "sectionsProcessed": 5,
    "overallStatus": "completed_with_warnings"
  },
  "timestamp": "2024-01-15T10:30:00Z"
}
```

## Usage Examples

### Basic Output Parsing

Parse structured output from a QB64PE program:

```javascript
const programOutput = `
=== EXECUTION_SUMMARY ===
Program: Graphics Demo
Start time: 2024-01-15 10:30:00
Timeout: 30 seconds

=== DEBUG_INFO ===
INFO: Graphics initialized
INFO: Loading image resources  
INFO: Entering main loop
INFO: Processing user input

=== ERROR_LOG ===
WARN: Low memory warning
ERROR: Image file not found

=== EXECUTION_END ===
Program completed
End time: 2024-01-15 10:30:14
Total time: 14 seconds
`;

const parsed = await parseQb64peStructuredOutput({
  output: programOutput
});

console.log("Parse successful:", parsed.parseSuccessful);
console.log("Sections found:", parsed.sectionsFound);
console.log("Execution status:", parsed.executionStatus);
console.log("Errors:", parsed.errors.length);
console.log("Warnings:", parsed.warnings.length);
```

### Error and Warning Analysis

Extract and analyze errors and warnings:

```javascript
const errorOutput = `
=== EXECUTION_SUMMARY ===
Program: File Processor
Start time: 2024-01-15 11:00:00

=== DEBUG_INFO ===
INFO: Initializing file processor
INFO: Scanning directory
WARN: Large file detected (>100MB)
ERROR: Permission denied for file access
ERROR: Disk space low

=== EXECUTION_END ===
Program terminated with errors
Exit code: 1
`;

const parsed = await parseQb64peStructuredOutput({
  output: errorOutput
});

console.log("Error Analysis:");
parsed.errors.forEach(error => {
  console.log(`${error.severity.toUpperCase()}: ${error.message}`);
  console.log(`Location: ${error.section}, Line: ${error.line}`);
});

console.log("\nWarning Analysis:");
parsed.warnings.forEach(warning => {
  console.log(`${warning.severity.toUpperCase()}: ${warning.message}`);
});

console.log("\nOverall Status:", parsed.summary.overallStatus);
```

### Performance Analysis

Extract performance and timing information:

```javascript
const performanceOutput = `
=== EXECUTION_SUMMARY ===
Program: Performance Test
Start time: 2024-01-15 12:00:00

=== DEBUG_INFO ===
INFO: Starting performance test
INFO: Processing 10000 iterations
INFO: Memory usage: 25MB
INFO: Processing time: 5.2 seconds
INFO: Memory usage: 67MB
INFO: Processing complete

=== RESOURCE_USAGE ===
Peak memory: 67MB
File handles: 12
Image handles: 5
Processing time: 5.2s

=== EXECUTION_END ===
Total execution time: 5.8 seconds
`;

const parsed = await parseQb64peStructuredOutput({
  output: performanceOutput
});

console.log("Performance Analysis:");
console.log("Execution time:", parsed.performance.executionTime);
console.log("Resource usage:", parsed.performance.resourceUsage);
if (parsed.performance.bottlenecks) {
  console.log("Bottlenecks:", parsed.performance.bottlenecks);
}
```

### Automated Testing Analysis

Parse output from automated test execution:

```javascript
const testOutput = `
=== TEST_EXECUTION ===
Test Suite: Graphics Functions
Tests: 15
Start time: 2024-01-15 13:00:00

=== DEBUG_INFO ===
INFO: Test 1 - Basic graphics: PASS
INFO: Test 2 - Image loading: PASS
WARN: Test 3 - Large image: SLOW (2.1s)
ERROR: Test 4 - Invalid format: FAIL
INFO: Test 5 - Graphics cleanup: PASS

=== TEST_RESULTS ===
Passed: 13
Failed: 2
Warnings: 1
Success rate: 86.7%

=== EXECUTION_END ===
Test execution completed
Duration: 12.3 seconds
`;

const parsed = await parseQb64peStructuredOutput({
  output: testOutput
});

console.log("Test Analysis:");
console.log("Overall status:", parsed.summary.overallStatus);
console.log("Test sections:", Object.keys(parsed.sections));

// Extract test-specific information
const testResults = parsed.sections.TEST_RESULTS;
if (testResults) {
  console.log("Test Results Section:");
  testResults.content.forEach(line => {
    console.log(`  ${line}`);
  });
}
```

## Integration Workflows

### Automated Testing Framework

```javascript
class TestOutputAnalyzer {
  async analyzeTestExecution(testOutput) {
    const parsed = await parseQb64peStructuredOutput({
      output: testOutput
    });
    
    return {
      testSummary: this.extractTestSummary(parsed),
      failureAnalysis: this.analyzeFailures(parsed),
      performanceMetrics: this.extractPerformanceMetrics(parsed),
      recommendations: this.generateRecommendations(parsed)
    };
  }
  
  extractTestSummary(parsed) {
    return {
      totalTests: this.countTests(parsed),
      passed: this.countPassed(parsed),
      failed: parsed.errors.length,
      warnings: parsed.warnings.length,
      executionTime: parsed.performance.executionTime,
      successRate: this.calculateSuccessRate(parsed)
    };
  }
  
  analyzeFailures(parsed) {
    return parsed.errors.map(error => ({
      test: this.extractTestName(error.message),
      reason: error.message,
      severity: error.severity,
      location: error.section,
      suggestions: this.suggestFix(error)
    }));
  }
  
  extractPerformanceMetrics(parsed) {
    return {
      executionTime: parsed.performance.executionTime,
      memoryUsage: this.extractMemoryUsage(parsed),
      resourceUtilization: this.extractResourceUtilization(parsed),
      bottlenecks: parsed.performance.bottlenecks || []
    };
  }
}
```

### Continuous Integration Integration

```javascript
class CIOutputProcessor {
  async processBuildOutput(buildOutput) {
    const parsed = await parseQb64peStructuredOutput({
      output: buildOutput
    });
    
    return {
      buildStatus: this.determineBuildStatus(parsed),
      buildReport: this.generateBuildReport(parsed),
      artifacts: this.extractArtifacts(parsed),
      nextActions: this.determineNextActions(parsed)
    };
  }
  
  determineBuildStatus(parsed) {
    if (parsed.errors.length > 0) {
      return 'failed';
    } else if (parsed.warnings.length > 0) {
      return 'unstable';
    } else if (parsed.executionStatus.completed) {
      return 'success';
    } else {
      return 'unknown';
    }
  }
  
  generateBuildReport(parsed) {
    return {
      summary: parsed.summary,
      sections: Object.keys(parsed.sections),
      issues: [...parsed.errors, ...parsed.warnings],
      performance: parsed.performance,
      recommendations: this.generateBuildRecommendations(parsed)
    };
  }
  
  determineNextActions(parsed) {
    const actions = [];
    
    if (parsed.errors.length > 0) {
      actions.push('Fix critical errors before deployment');
    }
    
    if (parsed.warnings.length > 0) {
      actions.push('Review warnings for potential issues');
    }
    
    if (parsed.performance.bottlenecks?.length > 0) {
      actions.push('Investigate performance bottlenecks');
    }
    
    return actions;
  }
}
```

### Development Debugging Assistant

```javascript
class DebuggingAssistant {
  async analyzeDebugOutput(debugOutput) {
    const parsed = await parseQb64peStructuredOutput({
      output: debugOutput
    });
    
    return {
      debugSummary: this.createDebugSummary(parsed),
      issueAnalysis: this.analyzeIssues(parsed),
      executionFlow: this.analyzeExecutionFlow(parsed),
      suggestions: this.generateDebugSuggestions(parsed)
    };
  }
  
  createDebugSummary(parsed) {
    return {
      programStatus: parsed.executionStatus,
      sectionsAnalyzed: parsed.sectionsFound,
      logMessagesProcessed: parsed.logMessages.length,
      issuesFound: parsed.errors.length + parsed.warnings.length,
      executionTime: parsed.performance.executionTime
    };
  }
  
  analyzeIssues(parsed) {
    const issues = [...parsed.errors, ...parsed.warnings];
    
    return {
      critical: issues.filter(i => i.severity === 'high'),
      moderate: issues.filter(i => i.severity === 'medium'),
      minor: issues.filter(i => i.severity === 'low'),
      categories: this.categorizeIssues(issues),
      patterns: this.identifyPatterns(issues)
    };
  }
  
  analyzeExecutionFlow(parsed) {
    const flow = [];
    
    Object.entries(parsed.sections).forEach(([sectionName, section]) => {
      flow.push({
        phase: sectionName,
        lineRange: `${section.startLine}-${section.endLine}`,
        messageCount: section.lineCount,
        issues: this.getIssuesInSection(sectionName, parsed)
      });
    });
    
    return flow;
  }
}
```

## Error Handling

The tool handles various output formats and edge cases:

### Malformed Output Handling

```javascript
const parseWithFallback = async (output) => {
  try {
    return await parseQb64peStructuredOutput({ output });
  } catch (error) {
    console.warn("Structured parsing failed, attempting basic parsing");
    
    return {
      parseSuccessful: false,
      outputType: "unstructured",
      rawOutput: output,
      basicAnalysis: {
        lineCount: output.split('\n').length,
        containsErrors: output.toLowerCase().includes('error'),
        containsWarnings: output.toLowerCase().includes('warn'),
        executionCompleted: output.includes('EXECUTION_END') || output.includes('completed')
      },
      error: error.message,
      suggestions: [
        "Output may not be from an enhanced QB64PE program",
        "Check if native logging was properly injected",
        "Verify structured output sections are present"
      ]
    };
  }
};
```

### Empty or Invalid Output

```javascript
const validateOutput = (output) => {
  if (!output || typeof output !== 'string') {
    throw new Error("Invalid output: must be a non-empty string");
  }
  
  if (output.trim().length === 0) {
    throw new Error("Empty output: no content to parse");
  }
  
  // Check for minimum structure
  if (!output.includes('===') && !output.includes('INFO:') && !output.includes('ERROR:')) {
    console.warn("Output appears to be unstructured");
  }
  
  return true;
};
```

### Large Output Processing

```javascript
const processLargeOutput = async (output) => {
  const maxSize = 1000000; // 1MB limit
  
  if (output.length > maxSize) {
    console.warn("Large output detected, processing in chunks");
    
    // Split into manageable chunks while preserving section boundaries
    const chunks = splitOutputAtSectionBoundaries(output, maxSize);
    const results = [];
    
    for (const chunk of chunks) {
      const chunkResult = await parseQb64peStructuredOutput({ output: chunk });
      results.push(chunkResult);
    }
    
    return mergeChunkResults(results);
  }
  
  return await parseQb64peStructuredOutput({ output });
};

const splitOutputAtSectionBoundaries = (output, maxChunkSize) => {
  const chunks = [];
  const sections = output.split(/(?====\s*\w+\s*===)/);
  
  let currentChunk = '';
  
  for (const section of sections) {
    if (currentChunk.length + section.length > maxChunkSize && currentChunk) {
      chunks.push(currentChunk);
      currentChunk = section;
    } else {
      currentChunk += section;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  
  return chunks;
};
```

## Best Practices

### 1. Output Validation

Always validate output before parsing:

```javascript
// Good: Validate before parsing
const validateAndParse = async (output) => {
  if (!output || output.trim().length === 0) {
    throw new Error("No output to parse");
  }
  
  return await parseQb64peStructuredOutput({ output });
};

// Good: Check for expected structure
const hasStructuredSections = (output) => {
  return output.includes('===') && 
         (output.includes('EXECUTION_') || output.includes('DEBUG_'));
};
```

### 2. Error Categorization

Categorize and prioritize errors appropriately:

```javascript
const categorizeErrors = (parsed) => {
  const categories = {
    critical: parsed.errors.filter(e => e.severity === 'high'),
    moderate: parsed.errors.filter(e => e.severity === 'medium'),
    minor: parsed.errors.filter(e => e.severity === 'low')
  };
  
  return {
    categories,
    priorityOrder: [...categories.critical, ...categories.moderate, ...categories.minor]
  };
};
```

### 3. Performance Monitoring

Extract and monitor performance metrics:

```javascript
const extractPerformanceMetrics = (parsed) => {
  return {
    executionTime: parsed.performance.executionTime,
    memoryPeak: extractMemoryPeak(parsed.sections),
    resourceUsage: extractResourceUsage(parsed.sections),
    bottlenecks: identifyBottlenecks(parsed.logMessages)
  };
};
```

### 4. Automated Response

Implement automated responses to common issues:

```javascript
const generateAutomatedResponse = (parsed) => {
  const responses = [];
  
  if (parsed.errors.length > 0) {
    responses.push("Critical errors detected - review error log");
  }
  
  if (parsed.executionStatus.timedOut) {
    responses.push("Execution timeout - consider optimizing or increasing timeout");
  }
  
  if (parsed.performance.executionTime > 30) {
    responses.push("Long execution time - investigate performance bottlenecks");
  }
  
  return responses;
};
```

## Cross-References

- **[inject_native_qb64pe_logging](./inject_native_qb64pe_logging.md)** - Native logging injection
- **[enhance_qb64pe_code_for_debugging](./enhance_qb64pe_code_for_debugging.md)** - Code debugging enhancement
- **[generate_advanced_debugging_template](./generate_advanced_debugging_template.md)** - Debug templates
- **[get_llm_debugging_guide](./get_llm_debugging_guide.md)** - LLM debugging guidance
- **[generate_output_capture_commands](./generate_output_capture_commands.md)** - Output capture

## See Also

- [Structured Output Examples](../docs/QB64PE_EXECUTION_MONITORING.md)
- [LLM Integration Guide](../docs/LLM_USAGE_GUIDE.md)
- [Debugging Enhancement System](../docs/QB64PE_DEBUGGING_ENHANCEMENT_SYSTEM.md)
